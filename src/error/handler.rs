use std::collections::VecDeque;

use crate::location::{Locatable, Location};

/// ErrorHandler is a struct that hold errors generated by the compiler
///
/// An error handler is used because multiple errors may be generated by each
/// part of the compiler, this cannot be represented well with Rust's normal
/// `Result`.
#[derive(Clone, Debug, PartialEq)]
pub struct ErrorHandler<E, W> {
    errors: VecDeque<Locatable<E>>,
    warnings: VecDeque<Locatable<W>>,
}

// Can't be derived because the derive mistakenly puts a bound of T: Default
impl<E, W> Default for ErrorHandler<E, W> {
    fn default() -> Self {
        Self {
            errors: Default::default(),
            warnings: Default::default(),
        }
    }
}

impl<E, W> ErrorHandler<E, W> {
    /// Construct a new error handler.
    pub fn new() -> ErrorHandler<E, W> {
        Default::default()
    }

    /// Warnings

    /// Whether any warnings have been seen and not handled
    pub(crate) fn has_warnings(&self) -> bool {
        self.warnings.is_empty()
    }

    pub fn warn<T: Into<W>>(&mut self, warning: T, location: Location) {
        self.warnings.push_back(location.with(warning.into()));
    }

    pub(crate) fn push_warning<T: Into<Locatable<W>>>(&mut self, error: T) {
        self.warnings.push_back(error.into());
    }

    pub(crate) fn pop_warning(&mut self) -> Option<Locatable<W>> {
        self.warnings.pop_front()
    }

    /// Add an iterator of warnings to the error queue
    pub(crate) fn extend_warnings<T: Into<Locatable<W>>>(&mut self, iter: impl Iterator<Item = T>) {
        self.warnings.extend(iter.map(Into::into));
    }

    pub(crate) fn take_warnings(&mut self) -> VecDeque<Locatable<W>> {
        std::mem::take(&mut self.warnings)
    }

    /// Errors

    /// Whether any errors have been seen and not handled
    pub(crate) fn has_errors(&self) -> bool {
        self.errors.is_empty()
    }

    pub(crate) fn error<T: Into<E>>(&mut self, error: T, location: Location) {
        self.errors.push_back(location.with(error.into()));
    }

    pub(crate) fn push_error<T: Into<Locatable<E>>>(&mut self, error: T) {
        self.errors.push_back(error.into());
    }

    pub(crate) fn pop_error(&mut self) -> Option<Locatable<E>> {
        self.errors.pop_front()
    }

    /// Add an iterator of errors to the error queue
    pub(crate) fn extend_errors<T: Into<Locatable<E>>>(&mut self, iter: impl Iterator<Item = T>) {
        self.errors.extend(iter.map(Into::into));
    }

    /// Move another `ErrorHandler`'s errors and warnings into this one.
    pub(crate) fn append<T, U>(&mut self, other: &mut ErrorHandler<T, U>)
    where
        E: From<T>,
        W: From<U>,
    {
        self.errors
            .extend(&mut other.errors.drain(..).map(|loc| loc.map(Into::into)));
        self.warnings
            .extend(&mut other.warnings.drain(..).map(|loc| loc.map(Into::into)));
    }
}

impl<E, W> Iterator for ErrorHandler<E, W> {
    type Item = Locatable<E>;

    fn next(&mut self) -> Option<Self::Item> {
        self.pop_error()
    }
}
